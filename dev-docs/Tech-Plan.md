1. High-Level ArchitectureWe will use Clean Architecture (Onion Architecture) to decouple business logic from the framework.Code snippetgraph TD
    Client[Web Frontend / API Client] -->|HTTP/JSON| Router[Fiber Router]
    
    subgraph "Application Core"
        Router --> Handler[Handler / Transport Layer]
        Handler --> Usecase[Usecase / Service Layer]
        Usecase --> RepoInterface[Repository Interfaces]
        Usecase --> Crypto[Encryption Service]
    end
    
    subgraph "Infrastructure"
        RepoInterface --> PGRepo[Postgres Implementation]
        RepoInterface --> RedisRepo[Redis Implementation]
        PGRepo --> DB[(PostgreSQL)]
        RedisRepo --> Cache[(Redis)]
    end
2. Technology StackLanguage: Golang 1.23+Web Framework: Go-Fiber (v2 or v3 beta)Database: PostgreSQL 16 (Driver: pgx/v5 for performance)Caching/Session: Redis 7Configuration: spf13/viper (Environment Variables)Testing: testify (Assertions), uber-go/mock (Mocking), testcontainers-go (Integration).3. Database Schema DesignTable: usersColumnTypeConstraintsDescriptionidUUIDPKInternal IDemailVARCHARUNIQUE, NOT NULLFrom Google OAuthnameVARCHARDisplay Namecreated_atTIMESTAMPTZTable: secretsColumnTypeConstraintsDescriptionidUUIDPKuser_idUUIDFK -> users.idOwnertitleVARCHARNOT NULLe.g. "Netflix"usernameVARCHARciphertextTEXTNOT NULLEncrypted password/notes payloadwebsite_urlVARCHARupdated_atTIMESTAMPTZNote: To simplify the "Backup" logic, we can store the sensitive data (password, notes) as a JSON blob encrypted in the ciphertext column, or keep columns separate. For this plan, we will keep columns separate but ensure the password field is encrypted before DB insertion.4. Security Architecture (The Backup Logic)This is the specific solution for your requirement: "backup password only can decrypt using this application".The Master Key: The application will require an environment variable APP_MASTER_KEY (32 bytes, hex-encoded).Backup Process:Fetch all user records from DB.Marshal to JSON.Encrypt the JSON blob using AES-256-GCM using the APP_MASTER_KEY.Return binary/blob file (e.g., backup.enc) to user.Restore Process:User uploads backup.enc.App attempts to decrypt using APP_MASTER_KEY.If decryption fails: It means the file is corrupt OR it came from a different app instance with a different key. Reject.If success: Unmarshal JSON and perform Upsert to DB.5. Development Phase (Tickets)These tickets follow the "Skeleton First" methodology.Phase 1: Foundation & Infrastructure[CORE-001] Project Scaffolding: Initialize Go module, setup Clean Architecture folders (internal/domain, internal/repository, internal/usecase, internal/handler), and configure viper for env vars.[CORE-002] Docker Environment: Create docker-compose.yml with Postgres, Redis, and a "Hello World" Fiber app. Ensure Healthchecks work.[CORE-003] Database Migrations: Setup golang-migrate and write SQL for users and secrets tables.Phase 2: Authentication[AUTH-001] Google OAuth2 Implementation: Implement goth or manual OIDC flow. Create POST /auth/login that redirects to Google.[AUTH-002] Session Management: Implement Middleware to validate JWT/Session via Redis. Protect routes.[TEST-001] Auth Unit Tests: Write table-driven tests for the Auth Usecase using Mockgen.Phase 3: Core Features (CRUD)[FEAT-001] Secret Repository: Implement Postgres CRUD for secrets using pgx.[FEAT-002] Encryption Service: Create a helper service for AES-GCM encryption (used for DB storage).[FEAT-003] Secret Usecase & Handler: Connect HTTP endpoints (GET, POST, PUT, DELETE /api/v1/secrets) to the repository.[FEAT-004] Password Generator: Create a utility function/endpoint to generate random passwords based on complexity rules.Phase 4: The Backup System (Special Requirement)[BACK-001] Backup Handler: Implement GET /api/v1/backup. Logic: Serialize all user secrets -> Encrypt with APP_MASTER_KEY -> Stream file download.[BACK-002] Restore Handler: Implement POST /api/v1/restore. Logic: Upload file -> Decrypt with APP_MASTER_KEY -> Parse -> Bulk Upsert.[TEST-002] Integration Tests: Use testcontainers to spin up a real Postgres, insert data, backup, clear DB, restore, and verify data exists.Phase 5: Frontend & Polish[UI-001] Web Dashboard: (Simple HTML/HTMX or React) Login page and Main Dashboard table.[OPS-001] CI/CD Pipeline: GitHub Actions to run go test ./... and golangci-lint.